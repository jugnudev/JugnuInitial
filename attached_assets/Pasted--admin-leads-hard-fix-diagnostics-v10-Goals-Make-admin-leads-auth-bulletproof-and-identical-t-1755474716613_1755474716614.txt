/admin/leads hard fix + diagnostics (v10)

Goals

Make /admin/leads auth bulletproof and identical to /admin/promote.

Support both backend path styles (/api/admin/leads* and /admin/leads/api*) to remove any drift.

Eliminate infinite spinners by showing explicit status/errors.

Add an opt-in diagnostics overlay (?debug=1) so we can see exactly what’s failing.

1) Backend: unify env + support both route shapes

a) requireAdminKey must check ONLY ADMIN_PASSWORD

// server/middleware/requireAdminKey.ts
export function requireAdminKey(req, res, next) {
  const key = req.header('x-admin-key') || '';
  const expected = process.env.ADMIN_PASSWORD || '';
  if (!key) return res.status(401).json({ ok:false, error:'Missing admin key' });
  if (key !== expected) return res.status(403).json({ ok:false, error:'Invalid admin key' });
  return next();
}


b) Mount BOTH route shapes to avoid drift

// server/adminLeadsRoutes.ts
import { requireAdminKey } from './middleware/requireAdminKey';

// canonical
app.get('/api/admin/leads', requireAdminKey, listLeads);
app.get('/api/admin/leads/:id', requireAdminKey, getLead);
app.post('/api/admin/leads/:id/status', requireAdminKey, updateStatus);
app.get('/api/admin/leads.csv', requireAdminKey, exportCSV);

// legacy alias (kept for compatibility)
app.get('/admin/leads/api', requireAdminKey, listLeads);
app.get('/admin/leads/api/:id', requireAdminKey, getLead);
app.post('/admin/leads/:id/status', requireAdminKey, updateStatus); // if this existed
app.get('/admin/leads/api.csv', requireAdminKey, exportCSV);

// diagnostics
app.get('/api/admin/echo-auth', requireAdminKey, (req, res) => res.json({ ok:true }));
console.log('[ADMIN] Routes mounted: /api/admin/leads*, /admin/leads/api*; requireAdminKey uses ADMIN_PASSWORD only');


This removes path/env ambiguity completely.

2) Frontend: one provider, one fetch, one login

Ensure both /admin/promote and /admin/leads are wrapped by the same AdminAuthProvider.

Ensure both pages use the same login component.

Ensure all admin fetches use the same hook that injects x-admin-key.

// src/lib/adminAuth.ts
export const ADMIN_LOCAL_KEY = 'jugnu-admin-dev-2025';
export const getAdminKey = () => localStorage.getItem(ADMIN_LOCAL_KEY) || '';
export const setAdminKey = (v: string) => { localStorage.setItem(ADMIN_LOCAL_KEY, v); window.dispatchEvent(new Event('jugnu-admin-key')); };
export const clearAdminKey = () => { localStorage.removeItem(ADMIN_LOCAL_KEY); window.dispatchEvent(new Event('jugnu-admin-key')); };

// src/lib/AdminAuthProvider.tsx
// (same as you have) provides { adminKey, isAuthed, login, logout }

// src/lib/useAdminFetch.ts
import { useAdminAuth } from './AdminAuthProvider';
export function useAdminFetch() {
  const { adminKey } = useAdminAuth();
  return (input: RequestInfo, init: RequestInit = {}) => {
    const headers = new Headers(init.headers || {});
    if (adminKey) headers.set('x-admin-key', adminKey);
    return fetch(input, { ...init, headers });
  };
}


Replace any remaining direct fetch calls in admin/leads with useAdminFetch(), and remove any credentials:'include' or session-based code paths.

3) AdminLeads: zero-spinner state machine + explicit errors

No queries run until authed.

If a request returns 401/403 → show login (no loop).

Show a visible error if any non-auth error occurs.

// AdminLeads.tsx (top-level render logic)
const { isAuthed, logout } = useAdminAuth();
const adminFetch = useAdminFetch();

const { data, error, isLoading } = useQuery({
  queryKey: ['admin-leads', filters],
  queryFn: async () => {
    // Try canonical first; fall back to legacy path if needed
    const tryPaths = ['/api/admin/leads', '/admin/leads/api'];
    for (const p of tryPaths) {
      const r = await adminFetch(`${p}?${new URLSearchParams(filters)}`);
      if (r.status === 401 || r.status === 403) throw new Error('UNAUTH');
      if (r.ok) return r.json();
    }
    throw new Error('FETCH_FAILED');
  },
  enabled: isAuthed,
  retry: false,
  refetchOnWindowFocus: false,
});

if (!isAuthed) return <AdminLogin />;

if (error) {
  const msg = (error as Error).message;
  if (msg === 'UNAUTH') { logout(); return <AdminLogin />; }
  return <div className="p-4 text-sm text-red-300 bg-red-900/30 rounded">
    <div className="font-semibold">Admin Leads failed to load</div>
    <div>Error: {msg}</div>
  </div>;
}

if (isLoading) return <div className="p-4 text-sm opacity-80">Loading leads…</div>;

4) Diagnostics overlay (enable with ?debug=1)

Add this at the top of the page component:

function AdminDebug() {
  const { adminKey, isAuthed } = useAdminAuth();
  const adminFetch = useAdminFetch();
  if (new URLSearchParams(location.search).get('debug') !== '1') return null;
  const test = async (path: string) => {
    const r = await adminFetch(path);
    console.log(path, r.status, await r.text());
  };
  return (
    <div className="p-2 text-xs bg-amber-900/40 rounded mb-2">
      <div>isAuthed: {String(isAuthed)} | keyLen: {adminKey.length}</div>
      <div className="flex gap-2 mt-1">
        <button onClick={()=>test('/api/admin/echo-auth')} className="underline">echo-auth</button>
        <button onClick={()=>test('/api/admin/leads')} className="underline">GET /api/admin/leads</button>
        <button onClick={()=>test('/admin/leads/api')} className="underline">GET /admin/leads/api</button>
      </div>
    </div>
  );
}


Render <AdminDebug /> above the table.

5) Kill remaining landmines

Remove lazy loading for AdminLeads (no Suspense during debugging).

Wrap the entire /admin tree in AdminShell so the provider is always present.

Ensure only ADMIN_PASSWORD is used anywhere; delete any ADMIN_KEY env.

6) Acceptance checklist (must verify now)

Open /admin/promote, enter jugnu1401.
Confirm localStorage['jugnu-admin-dev-2025'] is set.

Open /admin/leads?debug=1 (same tab).

The diagnostics bar shows isAuthed: true, keyLen > 0.

Click echo-auth → Console shows 200 {"ok":true}.

Page shows the leads table (no spinner).

Hard refresh /admin/leads → still authed and table loads fast.

Clear the localStorage key and refresh /admin/leads → the login UI appears immediately (no infinite loading).

If any of the GET buttons in the debug bar return 401/403, fix headers; if they return 404, fix route mounts (but the dual path above prevents this).