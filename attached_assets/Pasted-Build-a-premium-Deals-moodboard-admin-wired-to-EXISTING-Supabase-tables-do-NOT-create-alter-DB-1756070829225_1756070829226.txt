Build a premium “Deals” moodboard + admin, wired to EXISTING Supabase tables (do NOT create/alter DB).

0) Use these existing tables (already created in Supabase). Do not run SQL.

public.deals

id uuid pk, title text, merchant text, blurb text,

code text null, link_url text null,

image_desktop_url text, image_mobile_url text,

placement_slot int (1..12),

badge text null, terms_md text null,

status enum('draft','scheduled','published','archived'),

priority int default 0,

start_at timestamptz, end_at timestamptz,

created_at timestamptz default now(), updated_at timestamptz default now()

public.deals_metrics_daily

deal_id uuid fk -> deals.id, day date,

impressions int default 0, clicks int default 0,

primary key (deal_id, day)

RLS note: Public can SELECT only published/active deals; metrics table requires service-role (admin endpoints must use SUPABASE_SERVICE_ROLE). If the API needs to reload PostgREST cache, do it via select pg_notify('pgrst','reload schema') from a dedicated admin endpoint—don’t modify schema.

1) Public page: /deals (premium moodboard)

Grid: exactly 12 visible slots with varied shapes (no scrolling needed to see placeholders). Responsive CSS Grid:

Desktop (≥1024px) 6 columns, 12 rows unit grid. Use this layout:

Slot 1: Hero grid-area: span 4 / span 3 (big, landscape)

Slot 2: Tall span 4 / span 2 (vertical)

Slot 3: Wide span 2 / span 3

Slots 4–6: Square each span 2 / span 2

Slot 7: Tall span 4 / span 2

Slot 8: Wide span 2 / span 3

Slots 9–12: Square each span 2 / span 2

Tablet (≥768px & <1024px) 4 columns; preserve variety (hero spans 3×3, talls 2×3, wides 3×2, squares 2×2).

Mobile (<768px) 2 columns; stack cards, alternate tall/wide crops to keep “moodboard” vibe. All 12 slots still render (as cards).

Slot filling: For each slot number (1–12), pick one deal: status='published' AND now() BETWEEN start_at AND COALESCE(end_at,'infinity'), highest priority, tie-break newest updated_at.

Placeholders: If no active deal for a slot, render a beautiful placeholder tile (soft gradient + “More deals soon ✨”)—no link, no tracking.

Card design (premium):

Full-bleed image (desktop/mobile URL), gradient overlay, subtle glassy panel with:

Merchant pill, optional badge (e.g., “Back to School”)

Title and short blurb

If code exists: Copy code button with clipboard + toast (“Copied!”).

If link_url exists: Get deal button; else show “Show this in-store” helper and the valid date range.

Subtle hover: lift + shadow + 3% scale; respect “not clickable” tiles (no anchor if link_url null).

Accessibility: alt text (fallback to ${merchant} — ${title}).

Tracking:

Impression: IntersectionObserver at ≥50% viewport, debounced 10s per {dealId,slot} in localStorage.

Click: Only when link_url exists. Route via redirector (see API) with UTM merge.

SEO:

Page <title> and meta description for Vancouver deals.

JSON-LD for each visible deal:

Use Offer or a simple CreativeWork if no price; include name, description, startDate, endDate, and url (redirector if clickable).

Canonical /deals.

2) Public APIs (JSON only; never return HTML)

GET /api/deals/active?slots=12

Returns an array of length 12: [{ slot: 1..12, deal: {id, title, merchant, blurb, code, link_url, image_desktop_url, image_mobile_url, badge, terms_md, start_at, end_at} | null }]

Cache header: Cache-Control: public, max-age=60.

GET /api/deals/:id

Returns the single deal (published/active only for public; admins can use admin endpoints).

POST /api/deals/track

Body: { dealId: string, slot: number, type: 'impression' | 'click' }

Server uses service-role Supabase to upsert into deals_metrics_daily with:

day = (now() at time zone 'America/Vancouver')::date

Increment impressions or clicks accordingly.

Returns { ok: true }.

GET /r/deal/:dealId

Query: ?slot=1..12&to=<encoded_url>

Server logs a click via POST /api/deals/track (service-role) then 302 redirects to to, merging UTMs:

utm_source=jugnu, utm_medium=deals, utm_campaign=<dealId>, utm_content=slot-<n>

If deal has no link_url, return { ok:false, error:'No link for this deal' } (don’t render anchor on client for those).

3) Admin console: /admin/deals

New tab in the existing admin area.

Views:

List: filter by Status (draft/scheduled/published/archived), search by merchant/title. Show slot, priority, dates, updated_at.

Create/Edit Drawer:

Fields map 1:1 to columns. Validations:

placement_slot in 1..12

Published requires: image_desktop_url & image_mobile_url, plus either code or link_url (but allow neither when status is draft; publish should require at least one of code/link).

Actions: Save, Duplicate, Archive.

Preview grid: shows the 12-slot moodboard using current admin data (no caching).

Admin API (x-admin-key or session—match your existing approach). Use service-role server-side client:

GET /api/admin/deals/list?status=&q=

POST /api/admin/deals/upsert — if id present, update; else insert. Server sets updated_at=now().

POST /api/admin/deals/delete — soft delete: set status='archived'.

GET /api/admin/deals/selftest — seeds a temp deal in slot 12, writes 1 impression + 1 click, asserts increments in deals_metrics_daily, cleans up. Returns { ok:true, wrote:{ impressions:1, clicks:1 } }.

Safety: JSON responses only with clear errors; rate-limit admin endpoints; CSRF protection for session auth flows.

4) Frontend polish & behavior

Moodboard styles: Tailwind + modern, editorial feel. Big typography (display for hero), tight cards for squares, gentle gradients and glassy overlays. Maintain visual rhythm across breakpoints.

Non-clickable deals: If link_url is null, do not render anchor. Show code (if present), valid date range (start_at → end_at), and an “In-store promotion” hint.

Terms modal: If terms_md present, add a small “Terms” link that opens a modal rendering sanitized Markdown.

Performance: Lazy-load images with intrinsic aspect ratio; prefetch redirector on hover.

Nav: Add “Deals” to main nav (after Events). If there are fewer than 3 active deals, show a small “New” dot on the nav item for 7 days after first publish.

5) Analytics & QA

Debounce impressions client-side (10s per {dealId,slot}); also ignore duplicate impressions <2s server-side if you already have infra for that.

Add a small /api/admin/deals/dump?dealId=... (admin-key) to fetch raw rows from deals_metrics_daily for debugging.

Ensure /api/* never returns HTML (JSON only). Add content-type headers and friendly error mapping.

Include a “Run Deals Self-Test” button in /admin/deals that hits the selftest endpoint and shows PASS/FAIL with details.

6) Integration constraints

Do not modify DB schema or RLS. Assume:

Public read policy for published active deals exists.

Writes to metrics only via service-role on the server.

If a schema cache refresh is needed, trigger select pg_notify('pgrst','reload schema') from an admin endpoint—not by altering schema.

Acceptance criteria

/deals shows 12 tiles at all breakpoints; varied sizes per slot; empty slots render beautiful placeholders.

Deals without link_url are not clickable but still show info/codes/dates.

Impressions and clicks record correctly (check with admin self-test and dump endpoint).

Redirector appends UTMs without duplication and 302s correctly.

Admin can create/edit/publish/archive deals; preview grid reflects state.

All APIs return JSON only; no HTML fallbacks.

Design feels premium and modern.

Please implement exactly as above and keep your changes isolated to app code (no SQL migrations).